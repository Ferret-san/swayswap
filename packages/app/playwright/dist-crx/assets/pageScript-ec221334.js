import{h as c,A as u,o as d,z as l,V as i,y as h,v,C as o}from"./index-00fb7aa5.js";var a={accounts:"accounts",currentAccount:"currentAccount",connection:"connection",network:"network"},p="Fuel",w="FuelContentScript",g="message",f=class extends v{constructor(){super(),this.onCommunicationMessage=e=>{switch(e.type){case"response":this.onResponse(e);break;case"request":this.onRequest(e);break;case"event":this.onEvent(e);break;case"uiEvent":this.onUIEvent(e);break}},this.client=new o.JSONRPCClient(this.sendRequest.bind(this)),this.server=new o.JSONRPCServer}externalMethods(e){e.forEach(n=>{let t=n;n.name&&(t=n.name),this.server.addMethod(t,this[t].bind(this))})}async sendRequest(e){throw new Error("Send request not implemented")}sendResponse(e,n){throw new Error("Send response not implemented")}onEvent(e){e.events.forEach(n=>{this.emit(n.event,...n.params)})}onResponse(e){this.client.receive(e.response)}onRequest(e){this.server.receive(e.request).then(n=>{this.sendResponse(n,e)})}onUIEvent(e){}},y=class extends f{constructor(){super(),this.onMessage=e=>{const n=Object.freeze(e);if(!this.acceptMessage(n))return;const{data:t}=n;this.onCommunicationMessage(t)},window.addEventListener(g,this.onMessage.bind(this))}acceptMessage(e){return!0}postMessage(e,n){window.postMessage(e,n||window.origin)}};function E(e){const n=e.inputs?.map(t=>{switch(t.type){case i.Message:return t.recipient;case i.Coin:return t.owner;default:return}})[0];if(!n)throw new Error("No possible signer found!");return c.fromB256(h(n)).toString()}var m=class extends y{acceptMessage(e){const{data:n}=e;return e.origin===window.origin&&n.target===p}async sendRequest(e){e&&this.postMessage({type:"request",target:w,request:e})}async ping(){return this.client.timeout(1e3).request("ping",{})}async network(){return this.client.request("network",{})}async isConnected(){return this.client.request("isConnected",{})}async connect(){return this.client.request("connect",{})}async disconnect(){return this.client.request("disconnect",{})}async accounts(){return this.client.request("accounts",{})}async currentAccount(){return this.client.request("currentAccount",{})}async signMessage(e,n){if(!n.trim())throw new Error("Message is required");return this.client.request("signMessage",{address:e,message:n})}async sendTransaction(e,n,t){if(!e)throw new Error("Transaction is required");const r=t||e.signer||E(e);return this.client.request("sendTransaction",{address:r,provider:n,transaction:JSON.stringify(e)})}on(e,n){return super.on(e,n)}},C=class extends u{constructor(e,n){super(e,n),this.provider=n}async signMessage(e){return this.provider.walletConnection.signMessage(this.address.toString(),e)}async sendTransaction(e){return this.provider.sendTransaction({...e,signer:this.address.toString()})}},M=class extends d{constructor(e,n){super(e),this.walletConnection=n}async sendTransaction(e){const n=await this.walletConnection.sendTransaction(e,{url:this.url});return new l(n,this)}},s={},q=class extends m{constructor(){super(...arguments),this.utils={createAddress:e=>(console.warn("Do not use this method! It will be removed in the next release."),c.fromString(e))},this.events=a}async getProvider(){const e=await this.network();if(s.provider)return s.provider;const n=new M(e.url,this);return s.provider=n,this.on(a.network,async t=>{s.provider?.connect(t.url)}),s.provider}async getWallet(e){const n=await this.getProvider();return new C(e,n)}},b=e=>new Proxy(e,{get(n,t){return n[t]},set(n,t,r){return Object.hasOwn(n,t)&&["_eventsCount","_events"].includes(t)?(n[t]=r,!0):!1},defineProperty(n,t){return Object.hasOwn(n,t)?n[t]:!1},deleteProperty(){return!1}});function S(e){const n=b(new q);if(Object.defineProperty(e,"fuel",{value:n,writable:!1,enumerable:!0,configurable:!0}),typeof document<"u"){const t=new CustomEvent("FuelLoaded",{detail:n});document.dispatchEvent(t)}}S(window);
