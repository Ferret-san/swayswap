import{W as l,a as M,T as S,w as q,i as L,q as T,A as f,C as a,P as p,N as b,B as U,h as I}from"./BaseConnection-8eedf47b.js";import{M as c,P as E,C as w,B as C}from"./constants-dea61167.js";import{x as P,e as k,r as R}from"./index-65a4253e.js";async function N(){let n=0,e=0;try{const{top:t=0,left:s=0,width:o=0}=await chrome.windows.getLastFocused();e=t,n=s+(o-l)}catch{const{screenX:s,screenY:o,outerWidth:r}=window;e=Math.max(o,0),n=Math.max(s+(r-l),0)}return{left:n,top:e}}async function j(n){n&&chrome.tabs.remove(n)}async function x(n){if(!n?.windowId||!n?.tabId)return!1;try{if(await chrome.windows.get(n.windowId))return await chrome.tabs.update(n.tabId,{selected:!0}),await chrome.windows.update(n.windowId,{focused:!0}),!0}catch{}return!1}async function _(n){const{left:e,top:t}=await N();return(await chrome.windows.create({type:"popup",url:n,width:l,height:M+S,left:e,top:t}))?.id}function O(n){return n?.tab?.id}let d;const D=new Uint8Array(16);function W(){if(!d&&(d=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!d))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return d(D)}const i=[];for(let n=0;n<256;++n)i.push((n+256).toString(16).slice(1));function $(n,e=0){return(i[n[e+0]]+i[n[e+1]]+i[n[e+2]]+i[n[e+3]]+"-"+i[n[e+4]]+i[n[e+5]]+"-"+i[n[e+6]]+i[n[e+7]]+"-"+i[n[e+8]]+i[n[e+9]]+"-"+i[n[e+10]]+i[n[e+11]]+i[n[e+12]]+i[n[e+13]]+i[n[e+14]]+i[n[e+15]]).toLowerCase()}const B=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),v={randomUUID:B};function H(n,e,t){if(v.randomUUID&&!e&&!n)return v.randomUUID();n=n||{};const s=n.random||(n.rng||W)();if(s[6]=s[6]&15|64,s[8]=s[8]&63|128,e){t=t||0;for(let o=0;o<16;++o)e[t+o]=s[o];return e}return $(s)}function F(){return H()}const K="/assets/content-script-loader.contentScript-aaa4e9b9.js";async function V(){chrome.tabs.query({url:"<all_urls>"},n=>{n.forEach(e=>{e.id&&chrome.scripting.executeScript({target:{tabId:e.id,allFrames:!0},files:[K],injectImmediately:!0}).catch(()=>{})})})}chrome.runtime.onInstalled.addListener(n=>{n.reason===chrome.runtime.OnInstalledReason.INSTALL&&(chrome.tabs.create({url:q()}),V())});chrome.alarms.create("KeepAwake",{periodInMinutes:1});chrome.alarms.onAlarm.addListener(n=>{n.name==="KeepAwake"&&console.debug("[FUEL WALLET] KeepAwake signal")});function z(){const n={};return n.promise=new Promise((e,t)=>{n.reject=t,n.resolve=e}),n}const A=new Map,h=class{constructor(n){this.session=null,this.tabId=null,this.windowId=null,this.rejectAllRequests=e=>{e===this.eventId&&(j(this.tabId),this.client.rejectAllPendingRequests("Request cancelled without explicity response!"))},this.sendRequest=async e=>{if(this.eventId)this.communicationProtocol.postMessage({type:c.request,target:E,id:this.eventId,request:e});else throw new Error("UI not connected!")},this.onResponse=e=>{e.id===this.eventId&&e.response&&this.client.receive(e.response)},this.onUIEvent=e=>{if(this.session===e.session&&e.ready){const t=O(e.sender);this.tabId=t,this.eventId=e.id,this.openingPromise.resolve(this)}},this.communicationProtocol=n,this.openingPromise=z(),this.client=new P.JSONRPCClient(this.sendRequest),this.setupUIListeners(),this.setTimeout()}setTimeout(n=5e3){setTimeout(()=>{this.openingPromise.reject(new Error("PopUp not opened!"))},n)}setupUIListeners(){this.communicationProtocol.once(c.uiEvent,this.onUIEvent),this.communicationProtocol.on(c.response,this.onResponse),this.communicationProtocol.on(c.removeConnection,this.rejectAllRequests)}static async getCurrent(n){const e=A.get(n);return e&&await x({tabId:e.tabId,windowId:e.windowId})?e:null}async requestConnection(n){return this.client.request("requestConnection",n)}async signMessage(n){return this.client.request("signMessage",n)}async sendTransaction(n){return this.client.request("sendTransaction",n)}};let u=h;u.create=async(n,e,t)=>{const s=L(4),o=new h(t);A.set(n,o);const r=await _(`${T.popup}?s=${s}#${e}`);return o.session=s,o.windowId=r,o};u.open=async(n,e,t)=>{let s=await h.getCurrent(n);return s||(s=await h.create(n,e,t)),s.openingPromise.promise};class m{constructor(e){this.communicationProtocol=e,this.server=new P.JSONRPCServer,this.server.applyMiddleware(this.connectionMiddlware.bind(this)),this.setupListeners(),this.externalMethods([this.ping,this.isConnected,this.accounts,this.connect,this.network,this.disconnect,this.signMessage,this.sendTransaction,this.currentAccount])}static start(e){return new m(e)}setupListeners(){this.communicationProtocol.on(c.request,async e=>{const t=e.sender.origin,s=await this.server.receive(e.request,{origin:t});s&&this.communicationProtocol.postMessage({id:e.id,type:c.response,target:w,response:s})})}externalMethods(e){e.forEach(t=>{let s=t;t.name&&(s=t.name),this.server.addMethod(s,this[s].bind(this))})}async requireAccounts(){if((await f.getAccounts()).length===0)throw new Error("Unable to establish a connection. No accounts found")}async requireAccountConnecton(e,t){if(!e)throw new Error("connection not found");if(!e.accounts.includes(k.fromString(t||"0x00").toString()))throw new Error("address is not authorized for this connection.")}async requireConnection(e){if(!((e?.accounts||[]).length>0))throw new Error("Connection not established. Please call connect() first to request a connection")}async connectionMiddlware(e,t,s){if(t.method==="ping")return e(t,{origin:s.origin});const o=await a.getConnection(s.origin);return["connect","isConnected"].includes(t.method)?await this.requireAccounts():await this.requireConnection(o),e(t,{connection:o,origin:s.origin})}async sendEvent(e,t,s){this.communicationProtocol.broadcast(e,{target:w,type:c.event,events:[{event:t,params:s}]})}async ping(){return!0}async isConnected(e,t){return!!t.connection}async connect(e,t){const s=t.origin;let o=await a.getConnection(s);return o||(o=await(await u.open(s,p.requestConnection(),this.communicationProtocol)).requestConnection({origin:s})),o&&this.sendEvent(s,"connection",[!!o]),!!o}async disconnect(e,t){const s=t.origin;return s?(await a.removeConnection({origin:s}),this.sendEvent(s,"connection",[!1]),!0):!1}async accounts(e,t){const s=t.origin;return s?(await a.getConnection(s))?.accounts||[]:[]}async signMessage(e,t){const s=t.origin;return await this.requireAccountConnecton(t.connection,e.address),await(await u.open(s,p.requestMessage(),this.communicationProtocol)).signMessage({...e,origin:s})}async sendTransaction(e,t){await this.requireAccountConnecton(t.connection,e.address);const s=t.origin;if((await b.getSelectedNetwork())?.url!==e.provider.url)throw new Error([`${e.provider.url} is different from the user current network!`,"Request the user to add the new network. fuel.addNetwork([...])."].join(`
`));return await(await u.open(s,p.requestTransaction(),this.communicationProtocol)).sendTransaction({...e,origin:s})}async currentAccount(e,t){const s=await f.getCurrentAccount();return await this.requireAccountConnecton(t.connection,s?.address),s?.address}async network(){return{url:(await b.getSelectedNetwork())?.url}}}class G extends U{constructor(){super(),this.removePort=e=>{const t=this.ports.get(e);t&&(t.onMessage.removeListener(this.onMessage),this.ports.delete(e),this.emit(c.removeConnection,e))},this.postMessage=e=>{const t=this.ports.get(e.id);t&&t.postMessage(e)},this.broadcast=(e,t)=>{const s=Array.isArray(e)?e:[e];this.ports.forEach(o=>{s.includes(o.sender?.origin||"")&&o.postMessage(t)})},this.getPortId=e=>{for(const[t,s]of this.ports.entries())if(s===e)return t;return null},this.onMessage=(e,t)=>{if(t.sender?.id!==chrome.runtime.id||e.target!==C||!Object.keys(c).includes(e.type))return;const o=this.getPortId(t);this.emit(e.type,Object.freeze({...e,id:o,sender:t.sender}))},this.ports=new Map}addConnection(e){const t=F();this.ports.set(t,e),this.setupListeners(t)}setupListeners(e){const t=this.ports.get(e);t&&!t.onMessage.hasListener(this.onMessage)&&(t.onMessage.addListener(this.onMessage),t.onDisconnect.addListener(()=>this.removePort(e)))}on(e,t){return super.on(e,t)}destroy(){this.ports.forEach(e=>e.disconnect()),this.ports.clear()}}class J extends R{constructor(){super(),this.setupListeners()}setupListeners(){I.on("changes",e=>{e.forEach(t=>{switch(t.type){case 1:super.emit(`${t.table}:create`,t);break;case 2:super.emit(`${t.table}:update`,t);break;case 3:super.emit(`${t.table}:delete`,t);break}})}),I.open()}on(e,t){return super.on(e,t)}}class g{constructor(e){this.communicationProtocol=e,this.databaseObservable=new J,this.setupApplicationWatcher()}static start(e){return new g(e)}createEvents(e){return{target:w,type:c.event,events:e}}setupApplicationWatcher(){this.databaseObservable.on("networks:update",async e=>{if(!e.obj.isSelected)return;const s=(await a.getConnections()).map(o=>o.origin);this.communicationProtocol.broadcast(s,this.createEvents([{event:"network",params:[{id:e.obj.id,url:e.obj.url}]}]))}),this.databaseObservable.on("accounts:update",async e=>{if(!e.obj.isCurrent)return;const t=e.obj,o=(await a.getConnections()).filter(r=>r.accounts.includes(t?.address||"")).map(r=>r.origin);this.communicationProtocol.broadcast(o,this.createEvents([{event:"currentAccount",params:[e.obj.address]}]))})}}const y=new G;m.start(y);g.start(y);chrome.runtime.onConnect.addListener(n=>{if(n.sender?.id!==chrome.runtime.id){n.disconnect();return}n.name===C&&y.addConnection(n)});
