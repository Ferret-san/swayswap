import{e as a,Q as d,w as l,K as h,z as v,V as i,v as p,r as w,x as o}from"./index-65a4253e.js";var c={accounts:"accounts",currentAccount:"currentAccount",connection:"connection",network:"network"},g="Fuel",f="FuelContentScript",E="message",y=class extends w{constructor(){super(),this.onCommunicationMessage=e=>{switch(e.type){case"response":this.onResponse(e);break;case"request":this.onRequest(e);break;case"event":this.onEvent(e);break;case"uiEvent":this.onUIEvent(e);break}},this.client=new o.JSONRPCClient(this.sendRequest.bind(this)),this.server=new o.JSONRPCServer}externalMethods(e){e.forEach(n=>{let t=n;n.name&&(t=n.name),this.server.addMethod(t,this[t].bind(this))})}async sendRequest(e){throw new Error("Send request not implemented")}sendResponse(e,n){throw new Error("Send response not implemented")}onEvent(e){e.events.forEach(n=>{this.emit(n.event,...n.params)})}onResponse(e){this.client.receive(e.response)}onRequest(e){this.server.receive(e.request).then(n=>{this.sendResponse(n,e)})}onUIEvent(e){}},m=class extends y{constructor(){super(),this.onMessage=e=>{const n=Object.freeze(e);if(!this.acceptMessage(n))return;const{data:t}=n;this.onCommunicationMessage(t)},window.addEventListener(E,this.onMessage.bind(this))}acceptMessage(e){return!0}postMessage(e,n){window.postMessage(e,n||window.origin)}};function q(e){const n=e.inputs?.map(t=>{switch(t.type){case i.Message:return t.recipient;case i.Coin:return t.owner;default:return}})[0];if(!n)throw new Error("No possible signer found!");return a.fromB256(p(n)).toString()}var C=class extends m{acceptMessage(e){const{data:n}=e;return e.origin===window.origin&&n.target===g}async sendRequest(e){e&&this.postMessage({type:"request",target:f,request:e})}async ping(){return this.client.timeout(1e3).request("ping",{})}async network(){return this.client.request("network",{})}async isConnected(){return this.client.request("isConnected",{})}async connect(){return this.client.request("connect",{})}async disconnect(){return this.client.request("disconnect",{})}async accounts(){return this.client.request("accounts",{})}async currentAccount(){return this.client.request("currentAccount",{})}async signMessage(e,n){if(!n.trim())throw new Error("Message is required");return this.client.request("signMessage",{address:e,message:n})}async sendTransaction(e,n,t){if(!e)throw new Error("Transaction is required");const r=d(e),u=t||e.signer||q(r);return this.client.request("sendTransaction",{address:u,provider:n,transaction:JSON.stringify(r)})}on(e,n){return super.on(e,n)}},M=class extends l{constructor(e,n){super(e,n),this.provider=n}async signMessage(e){return this.provider.walletConnection.signMessage(this.address.toString(),e)}async sendTransaction(e){return this.provider.sendTransaction({...e,signer:this.address.toString()})}},b=class extends h{constructor(e,n){super(e),this.walletConnection=n}async sendTransaction(e){const n=await this.walletConnection.sendTransaction(e,{url:this.url});return new v(n,this)}},s={},S=class extends C{constructor(){super(...arguments),this.utils={createAddress:e=>(console.warn("Do not use this method! It will be removed in the next release."),a.fromString(e))},this.events=c}async getProvider(){const e=await this.network();if(s.provider)return s.provider;const n=new b(e.url,this);return s.provider=n,this.on(c.network,async t=>{s.provider?.connect(t.url)}),s.provider}async getWallet(e){const n=await this.getProvider();return new M(e,n)}},R=e=>new Proxy(e,{get(n,t){return n[t]},set(n,t,r){return Object.hasOwn(n,t)&&["_eventsCount","_events"].includes(t)?(n[t]=r,!0):!1},defineProperty(n,t){return Object.hasOwn(n,t)?n[t]:!1},deleteProperty(){return!1}});function P(e){const n=R(new S);if(Object.defineProperty(e,"fuel",{value:n,writable:!1,enumerable:!0,configurable:!0}),typeof document<"u"){const t=new CustomEvent("FuelLoaded",{detail:n});document.dispatchEvent(t)}}P(window);
